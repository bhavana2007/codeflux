{
  "id": "prefixSum",
  "name": "Prefix Sum",
  "description": "Precompute cumulative sums so subarray queries become O(1).",
  "difficulty": "Easy",
  "leetcode": "https://leetcode.com/problems/range-sum-query-immutable/",
  "overview": {
    "what": "Prefix sums store running totals so you can subtract two indices to get any range sum quickly.",
    "when": "Use when there are many range-sum queries over a static array.",
    "complexity": "Time: O(n) preprocess + O(1) per query | Space: O(n)"
  },
  "detect": "You need many range-sum queries over an array that will not change.",
  "mistakes": [
    "Using the original array instead of a length+1 prefix array",
    "Off-by-one when subtracting prefix indices",
    "Trying to use prefix sums on frequently updated arrays"
  ],
  "tips": "Build prefix with an extra 0 at the start. Range [l, r] is prefix[r+1] - prefix[l].",
  "problems": [
    { "title": "Range Sum Query - Immutable (LC 303)", "link": "https://leetcode.com/problems/range-sum-query-immutable/", "difficulty": "Easy" },
    { "title": "Subarray Sum Equals K (LC 560)", "link": "https://leetcode.com/problems/subarray-sum-equals-k/", "difficulty": "Medium" },
    { "title": "Find Pivot Index (LC 724)", "link": "https://leetcode.com/problems/find-pivot-index/", "difficulty": "Easy" }
  ],
  "postQuestion": { "question": "If the array changes frequently, should you use prefix sums?", "options": ["Yes, always", "No â€” recompute is expensive", "Only for very small arrays"], "correct": 1 },
  "video": "https://www.youtube.com/watch?v=MoAH0EcI7IQ",
  "defaultInputs": {
    "array": "[1, 2, 3, 4, 5]",
    "queryRange": "[1, 3]"
  },
  "codeByLanguage": {
    "javascript": [
      { "line": 0, "code": "function prefixSum(arr) {" },
      { "line": 1, "code": "  const pref = Array(arr.length + 1).fill(0);" },
      { "line": 2, "code": "  for (let i = 1; i < pref.length; i++) {" },
      { "line": 3, "code": "    pref[i] = pref[i - 1] + arr[i - 1];" },
      { "line": 4, "code": "  }" },
      { "line": 5, "code": "  const [l, r] = [1, 3];" },
      { "line": 6, "code": "  return pref[r + 1] - pref[l];" },
      { "line": 7, "code": "}" }
    ],
    "python": [
      { "line": 0, "code": "def prefix_sum(arr):" },
      { "line": 1, "code": "    pref = [0] * (len(arr) + 1)" },
      { "line": 2, "code": "    for i in range(1, len(pref)):" },
      { "line": 3, "code": "        pref[i] = pref[i-1] + arr[i-1]" },
      { "line": 4, "code": "    l, r = 1, 3" },
      { "line": 5, "code": "    return pref[r+1] - pref[l]" }
    ]
  },
  "quiz": [
    { "question": "Why use length+1 prefix array?", "options": ["To waste space", "To simplify range math with a leading 0", "To store indexes"], "correct": 1, "explanation": "The leading 0 makes range sums a single subtraction." },
    { "question": "Range sum [l, r] equals:", "options": ["pref[r] - pref[l]", "pref[r+1] - pref[l]", "pref[r] + pref[l]"], "correct": 1, "explanation": "Use r+1 because prefix stores sums up to index." },
    { "question": "When not to use prefix sums?", "options": ["Static arrays", "Many updates to array", "Many queries"], "correct": 1, "explanation": "Frequent updates break the precomputation advantage." }
  ],
  "codeSteps": [
    { "line": 0, "code": "function prefixSum(arr) {" },
    { "line": 1, "code": "  const pref = Array(arr.length + 1).fill(0);" },
    { "line": 2, "code": "  for (let i = 1; i < pref.length; i++) {" },
    { "line": 3, "code": "    pref[i] = pref[i - 1] + arr[i - 1];" },
    { "line": 4, "code": "  }" },
    { "line": 5, "code": "  const [l, r] = [1, 3];" },
    { "line": 6, "code": "  return pref[r + 1] - pref[l];" },
    { "line": 7, "code": "}" }
  ],
  "steps": [
    { "step": 0, "popup": "Create Prefix Array", "reason": "Allocate an extra slot (length + 1) to simplify math." },
    { "step": 1, "popup": "Initialize Zeros", "reason": "Start with all zeros; pref[0] is the neutral base." },
    { "step": 2, "popup": "Iterate Elements", "reason": "Walk through the array once to accumulate sums." },
    { "step": 3, "popup": "Build Running Total", "reason": "Each prefix is previous total plus current element." },
    { "step": 4, "popup": "Finish Preprocess", "reason": "We now have prefix sums for every index." },
    { "step": 5, "popup": "Read Query Range", "reason": "Take left/right bounds for the subarray sum." },
    { "step": 6, "popup": "Compute Range Sum", "reason": "Subtract prefix values to get constant-time answer." }
  ]
}
